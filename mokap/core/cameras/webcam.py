import logging

import cv2
import numpy as np
import time
from typing import Any, Dict, Optional, Tuple
from mokap.core.cameras.interface import AbstractCamera

logger = logging.getLogger(__name__)


class WebcamCamera(AbstractCamera):
    """
    Concrete implementation of AbstractCamera for generic USB webcams using OpenCV

    Many features like hardware triggering, precise exposure/gain control, and
    hardware timestamps are not available on standard webcams though
        - Synchronization relies on software timestamps generated by the host computer
        - Camera properties (exposure, gain, etc.) are often in arbitrary,
          device-specific units and may not be supported by all cameras
        - The unique_id is based on the camera's integer index, which may change
          if devices are plugged/unplugged
          # TODO: This is very annoying, maybe should use VID/PID? But OpenCV is pretty opaque with the cap interface...
    """

    def __init__(self, camera_index: int):
        """
        camera_index: integer index of the camera (for example 0 for /dev/video0 on Unix)
        """
        self._index = camera_index
        self._ptr: Optional[cv2.VideoCapture] = None
        self._frame_counter = 0
        super().__init__(unique_id=f'webcam_{camera_index}')

    def connect(self, config: Optional[Dict[str, Any]] = None) -> None:
        if self.is_connected:
            logger.warning(f'Camera {self.unique_id} is already connected.')
            return

        try:
            self._ptr = cv2.VideoCapture(self._index)
            # self._ptr = cv2.VideoCapture(self._index, cv2.CAP_DSHOW)
            # TODO: test more whether CAP_DSHOW is more stable (on Windows probably?)

            if not self._ptr.isOpened():
                raise IOError(f'Cannot open webcam with index {self._index}')

            self._is_connected = True
            self._apply_configuration(config)
            logger.info(f'Connected to Webcam: {self.unique_id}')

        except Exception as e:
            self._is_connected = False
            self._ptr = None
            raise RuntimeError(f'Failed to connect to Webcam {self.unique_id}: {e}') from e

    def _apply_configuration(self, config: Optional[Dict[str, Any]] = None):
        """ Applies a set of initial parameters to the camera. """
        if not self.is_connected:
            raise RuntimeError('Camera is not connected.')

        # Default configuration for a typical webcam
        settings = {
            'exposure': -6.0,  # Note: These units are arbitrary (often log base 2)
            'gain': 0.0,
            'framerate': 30.0,
            'pixel_format': 'BGR8',  # OpenCV usually likes BGR
            'roi': (0, 0, 640, 480),
            # The following are not supported but are in the abstract interface
            'hardware_triggered': False,
            'binning': 1,
            'binning_mode': 'average',
            'gamma': 100,  # Often a 0-255 scale
            'blacks': 0,
        }
        if config:
            settings.update(config)

        # Cache internal state
        self._roi = settings['roi']
        self._framerate = settings['framerate']
        self._exposure = settings['exposure']
        self._gain = settings['gain']
        self._gamma = settings['gamma']
        self._blacks = settings['blacks']

        # Apply settings to the webcam via property setters
        # ROI (which is really only resolution) should be set first
        self.roi = self._roi
        self.framerate = self._framerate

        # try to disable auto exposure
        self._set_cv2_property(cv2.CAP_PROP_AUTO_EXPOSURE, 0)  # 0 is manual

        self.exposure = self._exposure
        self.gain = self._gain
        self.gamma = self._gamma

        # After attempting to set, read back the actual values just to make sure
        self._roi = self.roi
        self._framerate = self.framerate

    def disconnect(self) -> None:

        if self._ptr and self._ptr.isOpened():
            self._ptr.release()

        self._ptr = None
        self._is_connected = False
        self._is_grabbing = False
        logger.info(f'Disconnected from Webcam: {self.unique_id}')

    def start_grabbing(self) -> None:
        if self.is_connected and not self.is_grabbing:
            # for OpenCV, being connected means it's ready to grab
            self._is_grabbing = True

    def stop_grabbing(self) -> None:
        self._is_grabbing = False

    def grab_frame(self, timeout_ms: int = 2000) -> Tuple[np.ndarray, Dict[str, Any]]:

        if not self.is_connected or not self._ptr.isOpened():
            raise RuntimeError('Webcam is not connected.')

        # OpenCV's read() is blocking and but timeout is not directly supported...
        ret, frame = self._ptr.read()
        # Generate a software timestamp immediately after the frame arrives
        timestamp = time.time_ns()

        if not ret or frame is None:
            raise IOError('Failed to grab frame from webcam.')

        self._frame_counter += 1
        metadata = {
            'frame_number': self._frame_counter,
            'timestamp': timestamp  # timestamp from host computer clock
        }
        return frame, metadata

    def _get_cv2_property(self, prop_id: int) -> Any:
        if self._ptr:
            return self._ptr.get(prop_id)
        return None

    def _set_cv2_property(self, prop_id: int, value: Any) -> bool:
        if self._ptr:
            return self._ptr.set(prop_id, value)
        return False

    # --- Properties implementation (well, the ones we can implement at least) ---

    @property
    def exposure(self) -> float:
        return self._get_cv2_property(cv2.CAP_PROP_EXPOSURE)

    @exposure.setter
    def exposure(self, value: float):
        self._set_cv2_property(cv2.CAP_PROP_EXPOSURE, value)
        self._exposure = self.exposure

    @property
    def gain(self) -> float:
        return self._get_cv2_property(cv2.CAP_PROP_GAIN)

    @gain.setter
    def gain(self, value: float):
        self._set_cv2_property(cv2.CAP_PROP_GAIN, value)
        self._gain = self.gain

    @property
    def blacks(self) -> float:
        return self._get_cv2_property(cv2.CAP_PROP_BRIGHTNESS)

    @blacks.setter
    def blacks(self, value: float):
        self._set_cv2_property(cv2.CAP_PROP_BRIGHTNESS, value)
        self._blacks = self.blacks

    @property
    def gamma(self) -> float:
        return self._get_cv2_property(cv2.CAP_PROP_GAMMA)

    @gamma.setter
    def gamma(self, value: float):
        self._set_cv2_property(cv2.CAP_PROP_GAMMA, value)
        self._gamma = self.gamma

    @property
    def framerate(self) -> float:
        return self._get_cv2_property(cv2.CAP_PROP_FPS)

    @framerate.setter
    def framerate(self, value: float):
        self._set_cv2_property(cv2.CAP_PROP_FPS, value)
        self._framerate = self.framerate

    @property
    def roi(self) -> Tuple[int, int, int, int]:
        w = int(self._get_cv2_property(cv2.CAP_PROP_FRAME_WIDTH))
        h = int(self._get_cv2_property(cv2.CAP_PROP_FRAME_HEIGHT))

        return 0, 0, w, h  # x, y offsets are not supported

    @roi.setter
    def roi(self, value: Tuple[int, int, int, int]):
        _, _, width, height = value

        self._set_cv2_property(cv2.CAP_PROP_FRAME_WIDTH, width)
        self._set_cv2_property(cv2.CAP_PROP_FRAME_HEIGHT, height)

        # cache the value that was set
        self._roi = (0, 0, width, height)

    @property
    def hardware_triggered(self) -> bool:
        return False

    @hardware_triggered.setter
    def hardware_triggered(self, enabled: bool):
        if enabled:
            raise NotImplementedError('Webcams do not support hardware triggering.')

    @property
    def pixel_format(self) -> str:
        # OpenCV generally only returns BGR format
        # TODO: Can that be changed?
        return 'BGR8'

    @pixel_format.setter
    def pixel_format(self, value: str):
        if value.upper() not in ['BGR8', 'BGR']:
            logger.warning(f'Webcam pixel format cannot be changed. It is typically BGR8.')

    # --- These are likely unsupported by all webcams, but we need to implement them ---

    @property
    def binning(self) -> Optional[int]:
        return None

    @binning.setter
    def binning(self, value: int):
        logger.warning('Webcams do not support hardware binning. Ignoring.')
        pass

    @property
    def binning_mode(self) -> Optional[str]:
        return None

    @binning_mode.setter
    def binning_mode(self, value: str):
        logger.warning('Webcams do not support hardware binning. Ignoring.')
        pass

    @property
    def temperature(self) -> Optional[float]:
        return None

    @property
    def temperature_state(self) -> Optional[str]:
        return None

    @property
    def sensor_shape(self) -> Tuple[int, int]:
        # There's no reliable way to get max sensor shape
        # We return the current resolution as a stand-in
        return self.roi[2], self.roi[3]
